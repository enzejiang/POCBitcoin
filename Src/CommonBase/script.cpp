// Copyright (c) 2009 Satoshi Nakamoto
// Distributed under the MIT/X11 software license, see the accompanying
// file license.txt or http://www.opensource.org/licenses/mit-license.php.

#include "script.h"
#include "key.h"
#include "WalletService/CTransaction.h"
#include "WalletService/WalletServ.h"

namespace Enze
{



bool CastToBool(const valtype& vch)
{
    return (CBigNum(vch) != bnZero);
}

void MakeSameSize(valtype& vch1, valtype& vch2)
{
    // Lengthen the shorter one
    if (vch1.size() < vch2.size())
        vch1.resize(vch2.size(), 0);
    if (vch2.size() < vch1.size())
        vch2.resize(vch1.size(), 0);
}




bool CheckSig(vector<unsigned char> vchSig, vector<unsigned char> vchPubKey, CScript scriptCode,
              const CTransaction& txTo, unsigned int nIn, int nHashType)
{
    CKey key;
    if (!key.SetPubKey(vchPubKey))
        return false;

    // Hash type is one byte tacked on to the end of the signature
    if (vchSig.empty())
        return false;
    if (nHashType == 0)
        nHashType = vchSig.back();
    else if (nHashType != vchSig.back())
        return false;
    vchSig.pop_back();

    if (key.Verify(SignatureHash(scriptCode, txTo, nIn, nHashType), vchSig))
        return true;

    return false;
}










// 验证交易对应的公钥是否满足下面的模板
bool Solver(const CScript& scriptPubKey, vector<pair<opcodetype, valtype> >& vSolutionRet)
{
    // Templates
    static vector<CScript> vTemplates;
    if (vTemplates.empty())
    {
        // Standard tx, sender provides pubkey, receiver adds signature
        vTemplates.push_back(CScript() << OP_PUBKEY << OP_CHECKSIG);

        // Short account number tx, sender provides hash of pubkey, receiver provides signature and pubkey
        vTemplates.push_back(CScript() << OP_DUP << OP_HASH160 << OP_PUBKEYHASH << OP_EQUALVERIFY << OP_CHECKSIG);
    }

    // Scan templates
    const CScript& script1 = scriptPubKey;
    foreach(const CScript& script2, vTemplates)
    {
        vSolutionRet.clear();
        opcodetype opcode1, opcode2;
        vector<unsigned char> vch1, vch2;

        // Compare
        CScript::const_iterator pc1 = script1.begin();
        CScript::const_iterator pc2 = script2.begin();
        loop
        {
            bool f1 = script1.GetOp(pc1, opcode1, vch1);
            bool f2 = script2.GetOp(pc2, opcode2, vch2);
            if (!f1 && !f2)
            {
                // Success
                reverse(vSolutionRet.begin(), vSolutionRet.end());
                return true;
            }
            else if (f1 != f2)
            {
                break;
            }
            else if (opcode2 == OP_PUBKEY)
            {
                if (vch1.size() <= sizeof(uint256))
                    break;
                vSolutionRet.push_back(make_pair(opcode2, vch1));
            }
            else if (opcode2 == OP_PUBKEYHASH)
            {
                if (vch1.size() != sizeof(uint160))
                    break;
                vSolutionRet.push_back(make_pair(opcode2, vch1));
            }
            else if (opcode1 != opcode2)
            {
                break;
            }
        }
    }

    vSolutionRet.clear();
    return false;
}

// 判断对应的公钥在mapKeys是否存在对应的私钥，如果存在说明此交易是节点本身自己的交易
bool Solver(const CScript& scriptPubKey, uint256 hash, int nHashType, CScript& scriptSigRet)
{
    scriptSigRet.clear();

    vector<pair<opcodetype, valtype> > vSolution;
    if (!Solver(scriptPubKey, vSolution))
        return false;
    const map<uint160, vector<unsigned char> >& mapPubKeys = WalletServ::getInstance()->getMapPubKeys();
    const map<vector<unsigned char>, CPrivKey>& mapKeys = WalletServ::getInstance()->getMapKeys();
    
    foreach(PAIRTYPE(opcodetype, valtype)& item, vSolution)
    {
        if (item.first == OP_PUBKEY)
        {
            // Sign
            const valtype& vchPubKey = item.second;
            if (!mapKeys.count(vchPubKey))
                return false;
            if (hash != 0)
            {
                vector<unsigned char> vchSig;
                if (!CKey::Sign(mapKeys.at(vchPubKey), hash, vchSig))
                    return false;
                vchSig.push_back((unsigned char)nHashType);
                scriptSigRet << vchSig;
            }
        }
        else if (item.first == OP_PUBKEYHASH)
        {
            // Sign and give pubkey
            map<uint160, valtype>::const_iterator mi = mapPubKeys.find(uint160(item.second));
            if (mi == mapPubKeys.end())
                return false;
            const vector<unsigned char>& vchPubKey = (*mi).second;
            if (!mapKeys.count(vchPubKey))
                return false;
            if (hash != 0)
            {
                vector<unsigned char> vchSig;
                if (!CKey::Sign(mapKeys.at(vchPubKey), hash, vchSig))
                    return false;
                vchSig.push_back((unsigned char)nHashType);
                scriptSigRet << vchSig << vchPubKey;
            }
        }
    }

    return true;
}



} //end namespace


/* EOF */
